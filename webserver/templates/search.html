<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <title>ImageDB – Compound Search</title>
  <link rel="shortcut icon" href="/static/pharmbio_logo_square_64x64.png" type="image/x-icon">

  <!-- Bootstrap & your CSS -->
  <link href="/static/theme/vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">
  <link href="/static/theme/css/simple-sidebar.css" rel="stylesheet">
  <link rel="stylesheet" href="/static/main.css?version=1.x">

  <style>
    /* Existing card/grid styling (used inside the tree leaves) */
    .thumb-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 120px));
      gap: .6rem;
      margin: .5rem 0 .5rem 1.25rem;
    }
    .thumb-card {
      position: relative;
      overflow: hidden;
      border-radius: 4px;
      background: #f8f8f8;
      cursor: pointer;
    }
    .thumb-card img {
      width: 100%;
      height: auto;
      transition: filter .2s;
    }
    .thumb-meta {
      position: absolute;
      bottom: 0; left: 0; right: 0;
      background: rgba(0,0,0,.45);
      color: #fff;
      font-size: .75rem;
      padding: .15rem;
      text-align: center;
    }

    /* Tree view */
    .tree details { margin: .25rem 0 .25rem .75rem; }
    .tree summary { cursor: pointer; user-select: none; outline: none; }
    .tree .badge {
      font-size: .75rem;
      background: #eef;
      border: 1px solid #cfe;
      padding: .05rem .35rem;
      border-radius: .4rem;
      margin-left: .4rem;
    }

    /* Date badge: soft yellow */
    .badge-date{
      background: #fff3cd;          /* light yellow */
      border: 1px solid #ffe8a1;    /* pale border */
      color: #7a5d00;               /* muted amber text */
      border-radius: .4rem;
      padding: .05rem .35rem;
      margin-left: .4rem;
      font-size: .75rem;
    }

    /* Controls layout */
    .control-label { margin-right: .5rem; }
    .control-input { width: 90px; }
    .control-input.w110 { width: 110px; }
    .control-input.w120 { width: 120px; }

    /* Pill counters */
    .pill {
      display: inline-block;
      padding: 0 .5rem;
      background: #f0f0f0;
      border-radius: 1rem;
      font-size: .75rem;
      margin-left: .35rem;
      color: #333;
    }
    </style>
</head>

<body>
  <!-- Top bar with search -->
  <nav class="navbar navbar-light bg-light border-bottom">
    <form id="search-form" class="form-inline mx-3" onsubmit="return false;">
      <select id="field" class="form-control mr-2">
        <option value="">Compound: Any Field</option>
        <option value="inchi">Compound: inchi</option>
        <option value="compound_name">Compound: compound_name</option>
        <option value="batchid">Compound: batchid</option>
        <option value="cbkid">Compound: cbkid</option>
        <option value="libid">Compound: libid</option>
        <option value="libtxt">Compound: libtxt</option>
        <option value="smiles">Compound: smiles</option>
        <option value="inkey">Compound: inkey</option>
      </select>
      <input type="text" id="q" class="form-control mr-2" placeholder="Search term...." required>
      <button class="btn btn-info" type="submit">Search</button>
    </form>
  </nav>

  <div class="container-fluid mt-3">
    <!-- Controls: brightness, zoom, limits -->
    <div class="form-inline mb-3">
      <label class="control-label mr-3">
        Brightness
        <input type="range" id="brightness-range" min="0" max="3000" value="300" class="form-control-range ml-2">
      </label>
      <label class="control-label mr-4">
        Zoom
        <input type="range" id="zoom-range" min="50" max="200" value="150" class="form-control-range ml-2">
      </label>

      <label class="control-label mr-2">Limit plates
        <input type="number" id="limit-plates" class="form-control ml-2 control-input" min="1" placeholder="∞">
      </label>
      <label class="control-label mr-2">Limit acq/plate
        <input type="number" id="limit-acqs" class="form-control ml-2 control-input w110" min="1" placeholder="∞">
      </label>
      <label class="control-label mr-2">Limit wells/plate
        <input type="number" id="limit-wells" class="form-control ml-2 control-input w120" min="1" placeholder="∞">
      </label>
      <label class="control-label mr-2">Limit sites/well
        <input type="number" id="limit-sites" class="form-control ml-2 control-input w110" min="1" placeholder="∞">
      </label>
    </div>


    <!-- Results summary row -->
    <div class="mb-2">
      <span>Projects <span id="count-projects" class="pill">0</span></span>
      <span class="ml-2">Plates <span id="count-plates" class="pill">0</span></span>
      <span class="ml-2">Acquisitions <span id="count-acqs" class="pill">0</span></span>
      <span class="ml-2">Wells <span id="count-wells" class="pill">0</span></span>
    </div>

    <!-- Expand all -->
    <div class="mb-2">
      <button id="expand-all-btn" class="btn btn-sm btn-secondary mr-3">Expand all</button>
      <button id="sort-mode-btn" class="btn btn-sm btn-outline-secondary">Sort: Date (latest)</button>
    </div>

    <!-- Tree root -->
    <div id="tree-root" class="tree"></div>
  </div>

  <!-- Error Modal -->
  <div id="error-modal" class="modal fade" tabindex="-1" role="dialog" aria-hidden="true">
    <div class="modal-dialog modal-lg"><div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Error</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span>×</span></button>
      </div>
      <div class="modal-body"><pre id="error-message" style="white-space:pre-wrap"></pre></div>
    </div></div>
  </div>

  <!-- JS deps -->
  <script src="/static/theme/vendor/jquery/jquery.min.js"></script>
  <script src="/static/theme/vendor/bootstrap/js/bootstrap.bundle.min.js"></script>
  <!-- Keep your site-wide JS if needed -->
  <script src="/static/main.js?version=1.23"></script>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      function sleep(ms){return new Promise(r=>setTimeout(r, ms));}

      // --- Concurrency limiter for fetches (limits parallel plate/well loads) ---
      const SEM_MAX_CONCURRENT = 4; // tune if you want more/less parallelism
      let semInFlight = 0;
      async function withSemaphore(fn) {
        while (semInFlight >= SEM_MAX_CONCURRENT) { await sleep(30); }
        semInFlight++;
        try { return await fn(); }
        finally { semInFlight--; }
      }

      // Smoother "Expand all": expand level-by-level and then nudge images to eager
      async function expandAllTree(){
        const root = document.getElementById('tree-root');
        if(!root) return;

        // Expand progressively so lazy loaders can attach and populate
        const pass = async (selector, delay=40) => {
          const nodes = Array.from(root.querySelectorAll(selector));
          for (const d of nodes) { d.open = true; await sleep(delay); }
        };
        await pass(':scope > details', 40);               // projects
        await pass('details > details', 30);              // plates
        await pass('details > details > details', 25);    // acquisitions
        await pass('details details details details', 10);// wells

        // Make images download promptly once nodes exist
        root.querySelectorAll('img[loading="lazy"]').forEach(img => {
          try {
            img.loading = 'eager';
            img.decoding = 'async';
            img.setAttribute('fetchpriority','high');
          } catch(e){}
        });
      }
      const expandBtn = document.getElementById('expand-all-btn');
      if (expandBtn) expandBtn.addEventListener('click', () => { expandAllTree(); });

      // Sort mode (projects): 'date' (latest first) or 'name' (A–Ö)
      let SORT_MODE = 'date';
      const sortBtn = document.getElementById('sort-mode-btn');
      if (sortBtn) {
        sortBtn.addEventListener('click', () => {
          SORT_MODE = (SORT_MODE === 'date') ? 'name' : 'date';
          sortBtn.textContent = SORT_MODE === 'date' ? 'Sort: Date (latest)' : 'Sort: Name (A–Ö)';
          const term = document.getElementById('q').value.trim();
          if (term) {
            // Re-render with the new sort mode (simple approach: re-run current search)
            renderSearchResults(term);
          }
        });
      }

      const treeRoot     = document.getElementById('tree-root');
      const errorModal   = $('#error-modal');
      const errorMsgPre  = document.getElementById('error-message');
      const brightnessEl = document.getElementById('brightness-range');
      const C = {
        projects: document.getElementById('count-projects'),
        plates:   document.getElementById('count-plates'),
        acqs:     document.getElementById('count-acqs'),
        wells:    document.getElementById('count-wells'),
      };
      function setCounts(obj) {
        if (!C.projects) return;
        C.projects.textContent = obj.projects ?? 0;
        C.plates.textContent   = obj.plates ?? 0;
        C.acqs.textContent     = obj.acquisitions ?? 0;
        C.wells.textContent    = obj.wells ?? 0;
      }
      function computeCounts(projectsRootObj) {
        const result = { projects: 0, plates: 0, acquisitions: 0, wells: 0 };
        if (!projectsRootObj) return result;
        const projEntries = Object.entries(projectsRootObj);
        result.projects = projEntries.length;
        for (const [, proj] of projEntries) {
          const plates = proj?.plates ? Object.entries(proj.plates) : [];
          result.plates += plates.length;
          for (const [, plate] of plates) {
            const acqs = plate?.acquisitions ? Object.entries(plate.acquisitions) : [];
            result.acquisitions += acqs.length;
            for (const [, acq] of acqs) {
              const wells = acq?.wells ? acq.wells.length : 0;
              result.wells += wells;
            }
          }
        }
        return result;
      }

      const zoomEl       = document.getElementById('zoom-range');

      function showError(text) {
        errorMsgPre.textContent = text;
        errorModal.modal('show');
      }

      // Format ISO date string in Swedish locale
      const fmtDate = (iso) => {
        const d = new Date(iso);
        return Number.isNaN(d) ? (iso?.slice?.(0,10) ?? "") : d.toLocaleDateString('sv-SE');
      };

      function getLimit(id) {
        const v = parseInt(document.getElementById(id).value, 10);
        return Number.isFinite(v) && v > 0 ? v : Infinity;
      }

      function applyImageSettings(rootEl = document) {
        const b = (parseInt(brightnessEl.value,10) || 100) / 100;
        const z = (parseInt(zoomEl.value,10) || 100) / 100;
        rootEl.querySelectorAll('.thumb-card img').forEach(img => {
          img.style.filter = `brightness(${b})`;
        });
        const size = 120 * z;
        rootEl.querySelectorAll('.thumb-grid').forEach(grid => {
          grid.style.gridTemplateColumns = `repeat(auto-fit, minmax(${size}px, ${size}px))`;
        });
      }

      brightnessEl.addEventListener('input', () => applyImageSettings(treeRoot));
      zoomEl.addEventListener('input', () => applyImageSettings(treeRoot));

      // Re-render on limit changes if a term is present
      ['limit-plates','limit-acqs','limit-wells','limit-sites'].forEach(id => {
        const el = document.getElementById(id);
        if (el) el.addEventListener('change', () => {
          const term = document.getElementById('q').value.trim();
          if (term) renderSearchResults(term);
        });
      });

      // Cache plate fetches by (barcode|acqId|wellsCsv)
      const plateCache = new Map();

      function thumbUrlFromChannels(chArr) {
        const paths = chArr.slice(0,3).map(c => encodeURIComponent(c?.path || ''));
        while (paths.length < 3) paths.push(paths[paths.length-1] || '');
        return `/api/image-merge-thumb/ch1/${paths[0]}/ch2/${paths[1]}/ch3/${paths[2]}/channels.png`;
      }

      function makeDetails(summaryText, extra = '') {
        const d = document.createElement('details');
        const s = document.createElement('summary');
        s.innerHTML = summaryText + (extra ? ` <span class="badge">${extra}</span>` : '');
        d.appendChild(s);
        return [d, s];
      }

      async function fetchPlateSubset(barcode, acqId, wellsCsv) {
        const key = `${barcode}|${acqId}|${wellsCsv}`;
        if (plateCache.has(key)) return plateCache.get(key);
        const resp = await withSemaphore(() =>
          fetch(`/api/plate/${encodeURIComponent(barcode)}/${acqId}/${wellsCsv}`)
        );
        if (!resp.ok) throw new Error(`Fetch plate failed: ${barcode} acq ${acqId}`);
        const json = await resp.json();
        plateCache.set(key, json);
        return json;
      }

      // Put these once (top-level)
      let renderToken = 0;
      let currentAbort = null;

      // --- render function (no cache) ---
      async function renderSearchResults(term) {
        const treeRoot = document.getElementById('tree-root');

        // Abort any in-flight render
        if (currentAbort) currentAbort.abort();
        currentAbort = new AbortController();
        const { signal } = currentAbort;

        // Token to invalidate stale async work
        const myToken = ++renderToken;

        // Hard clear existing tree
        treeRoot.replaceChildren();

        // local helpers (no cache)
        async function fetchJSON(url, signal) {
          const resp = await fetch(url, { signal });
          if (!resp.ok) throw new Error(`${resp.status} ${resp.statusText}`);
          return resp.json();
        }
        async function fetchPlateSubsetInner(barcode, acqId, wellsCsv, signal) {
          // use semaphore here too for inner fetch path
          return withSemaphore(() => fetchJSON(`/api/plate/${encodeURIComponent(barcode)}/${acqId}/${wellsCsv}`, signal));
        }
        function makeDetailsInner(summaryText, badgeText = '') {
          const d = document.createElement('details');
          const s = document.createElement('summary');
          s.innerHTML = summaryText + (badgeText ? ` <span class="badge">${badgeText}</span>` : '');
          d.appendChild(s);
          return [d, s];
        }
        function thumbUrlFromChannelsInner(chArr) {
          const paths = chArr.slice(0, 3).map(c => encodeURIComponent(c?.path || ''));
          while (paths.length < 3) paths.push(paths[paths.length - 1] || '');
          return `/api/image-merge-thumb/ch1/${paths[0]}/ch2/${paths[1]}/ch3/${paths[2]}/channels.png`;
        }

        const L_PLATES = getLimit('limit-plates');
        const L_ACQS   = getLimit('limit-acqs');
        const L_WELLS  = getLimit('limit-wells');
        const L_SITES  = getLimit('limit-sites');

        // Build query string (also pass limits to server)
        const qs = new URLSearchParams({
          q: term,
          limit: '100000',
          ...(Number.isFinite(L_PLATES) ? { limit_plates: String(L_PLATES) } : {}),
          ...(Number.isFinite(L_ACQS)   ? { limit_acqs:   String(L_ACQS)   } : {}),
          ...(Number.isFinite(L_WELLS)  ? { limit_wells:  String(L_WELLS)  } : {}),
        }).toString();

        // Fetch hierarchical search result
        let json;
        try {
          json = await fetchJSON(`/api/search-compound?${qs}`, signal);
        } catch (e) {
          if (signal.aborted) return; // superseded by a newer render
          showError(String(e));
          return;
        }
        if (myToken !== renderToken) return;

        const projectsRootObj = json?.data?.projects;
        // Update summary counts
        const countsFromMeta = json && json.meta && json.meta.counts ? json.meta.counts : null;
        setCounts(countsFromMeta || computeCounts(projectsRootObj));
        if (!projectsRootObj || !Object.keys(projectsRootObj).length) {
          setCounts({projects:0, plates:0, acquisitions:0, wells:0});
          treeRoot.textContent = 'No results found.';
          return;
        }

        // Root: "Projects"
        const [projectsRoot] = makeDetailsInner('Projects');
        projectsRoot.open = true;
        if (myToken !== renderToken) return;
        treeRoot.appendChild(projectsRoot);


        // Iterate: project -> plates -> acquisitions -> wells
        // Sort projects by date (latest first) or by name (A–Ö) based on SORT_MODE
        const projectEntries = Object.entries(projectsRootObj);
        projectEntries.sort((a, b) => {
          if (SORT_MODE === 'name') {
            return a[0].localeCompare(b[0], 'sv-SE', { sensitivity: 'base' });
          } else {
            const da = Date.parse(a[1]?.date_iso || '') || 0;
            const db = Date.parse(b[1]?.date_iso || '') || 0;
            return db - da; // latest first
          }
        });
        for (const [projectName, projectObj] of projectEntries) {
          if (myToken !== renderToken) return;

          const projDateHTML = projectObj?.date_iso
            ? ` <span class="badge-date">${fmtDate(projectObj.date_iso)}</span>`
            : '';
          const [projDet] = makeDetailsInner(`${projectName}${projDateHTML}`);
          projectsRoot.appendChild(projDet);


          const plates = projectObj?.plates || {};
          const plateEntries = Object.entries(plates).slice(
            0, Number.isFinite(L_PLATES) ? L_PLATES : undefined
          );

          for (const [barcode, plateObj] of plateEntries) {
            if (myToken !== renderToken) return;

            const acqs = plateObj?.acquisitions || {};
            const acqEntries = Object.entries(acqs).slice(
              0, Number.isFinite(L_ACQS) ? L_ACQS : undefined
            );

            const [plateDet] = makeDetailsInner(`Plate ${barcode}`, `${acqEntries.length} acq`);
            plateDet.dataset.barcode = barcode;
            projDet.appendChild(plateDet);

            // Lazy build acquisitions when plate is expanded
            plateDet.addEventListener('toggle', () => {
              if (!plateDet.open || plateDet.dataset.loaded === '1') return;
              if (myToken !== renderToken) return;

              for (const [acqId, acqObj] of acqEntries) {
                const wellsArr = Array.isArray(acqObj?.wells) ? acqObj.wells : [];
                const wellsPlanned = wellsArr.slice(
                  0, Number.isFinite(L_WELLS) ? L_WELLS : undefined
                );

                // ✨ Add the date from the API (ISO string) after the acquisition id
                const acqDateHTML = acqObj?.date_iso
                  ? ` <span class="badge-date">${fmtDate(acqObj.date_iso)}</span>`
                  : '';
                const [acqDet] = makeDetailsInner(`Acq ${acqId}${acqDateHTML}`, `${wellsPlanned.length} wells`);
                acqDet.dataset.acqId = acqId;
                plateDet.appendChild(acqDet);

                // Lazy load thumbnails for the acquisition
                acqDet.addEventListener('toggle', async () => {
                  if (!acqDet.open || acqDet.dataset.loaded === '1') return;
                  if (myToken !== renderToken) return;

                  let plateJson;
                  try {
                    const wellsCsv = wellsPlanned.join(',');
                    plateJson = await fetchPlateSubsetInner(barcode, acqId, wellsCsv, signal);
                  } catch (e) {
                    if (signal.aborted || myToken !== renderToken) return;
                    console.error(e);
                    showError(String(e));
                    return;
                  }
                  if (myToken !== renderToken) return;

                  const plateNode = plateJson?.data?.plates?.[barcode];
                  const acqMap    = plateNode?.acquisitions || {};
                  const acqRec    = acqMap[String(acqId)] ?? acqMap[Number(acqId)];
                  const wellsObj  = acqRec?.wells || {};

                  const grid = document.createElement('div');
                  grid.className = 'thumb-grid';
                  acqDet.appendChild(grid);

                  for (const wellId of wellsPlanned) {
                    if (myToken !== renderToken) return;

                    const wellData = wellsObj[wellId];
                    if (!wellData) continue;

                    let sitesRendered = 0;
                    for (const [siteKey, siteInfo] of Object.entries(wellData.sites || {})) {
                      if (sitesRendered >= (Number.isFinite(L_SITES) ? L_SITES : Infinity)) break;

                      const zInfo = Object.values(siteInfo.z_positions || {})[0] || {};
                      let ch = Array.isArray(zInfo.channels)
                        ? zInfo.channels
                        : Object.values(zInfo.channels || {});
                      while (ch.length < 3) ch.push(ch[ch.length - 1] || {});
                      const thumb = thumbUrlFromChannelsInner(ch);

                      const card = document.createElement('div');
                      card.className = 'thumb-card';
                      card.innerHTML = `
                        <img src="${thumb}" alt="Well ${wellId} • Site ${siteKey}">
                        <div class="thumb-meta">Well ${wellId} • Site ${siteKey}</div>
                      `;
                      card.onclick = () => window.openViewer?.(wellId, siteKey);
                      grid.appendChild(card);

                      sitesRendered++;
                    }
                  }

                  applyImageSettings(acqDet);
                  acqDet.dataset.loaded = '1';
                });
              }

              plateDet.dataset.loaded = '1';
            });
          }
        }
      }


      // Hook search form
      document.getElementById('search-form').addEventListener('submit', e => {
        e.preventDefault();
        renderSearchResults(document.getElementById('q').value.trim());
      });
    });

  </script>
</body>
</html>
